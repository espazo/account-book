# 简易的记账本

纯原生的 JavaScript 程序，没有使用任何框架。


## 如何使用

代码保存在本地以后。需要一台已经连接了互联网，且能够正常访问 GitHub 的计算机。然后双击 `index.html` 通过浏览器打开，即可进入程序。


## 文件结构

### `index.html`：网页的内容结构。

#### 组成部分

- 筛选的 select 下拉框
- 内容主体
- 模态框

### `master.css`：网页的样式。

仅仅做了样式的基础调整。

### `master.js`：网页的逻辑结构。

#### 组成部分

- 数据的管理模块：
    - 数据的拉取
    - 本地存储
    - 筛选
    - 排序
    - 字段的可视化转换
    - 收入和支出的统计

- 内容的展示模块
    - 通过 `select` 的 `onchange` 事件获取筛选条件
    - 再通过 `数据的管理模块` 得到相应且根据日期排好序的数
    - 再动态加载到 `<table>` 元素里面。

- 模态框的展示模块
    - 模态框的打开与关闭
    - 获取表单数据
    - 再通过 `数据的管理模块` 保存
    - 重新更新 `<select>` 和 `<table>` 进行内容展示

## 函数构成

建议通过有 `代码折叠` 功能的代码编辑器来阅读笔者的代码，否则较难搞清楚其中的逻辑顺序。但其实，只要利用好 `代码折叠` 功能，就会发现这一份有良好设计的，且模块化的非常容易定位和查错的代码。

---

`function e(selectors)`

获取 `HTML` 元素。

---

`function es(selectors)`

获取一组 `HTML` 元素。

---

`function async database()`

关于数据的管理，都通过这个数据进行。

---

`env  = { database: {} }`

`env` 对象里会存放其它函数需要用到的函数实例。目前对象里只放有 `database()` 的实例，其它函数调用通过 `env.database` 来操纵数据。

---

`function show()`

用来展示网页的主要内容，以及相关用来筛选的代码。

---

`function the_add_bill()`

有关于模态框的相关代码。

---

`__main()`

主函数，函数的入口。

---

函数里面的构造，也大致是这样的设计，可以很容易通过函数名称看出函数所要做的事情。

## 思考过程

前端是一个数据可视化的过程。而网页的页面的设计，会探测用户的使用意图。我们通过前端用户的使用意图去得到新的数据，再把这些数据反馈给用户。以此往复。

为笔者我设计了专门用来处理数据的 `database()` 函数，用于展示数据的 `show()` 函数，以及处理模态框添加账单的 `the_add_bill()` 函数。

使程序的可扩展性大大提高。在后续的开发当中，可以很轻易的替换任意一个函数实现，且定定位到任意的一个小小功能，用于新增和修改功能。

## 遇到的问题和解决方案

在通过前端拉取数据的时候是异步的，可是异步的处理进度是不确定的，如果不做相关处理。那么页面的渲染，和拉取数据就不会同步，非常容易出错。

但是单单只是简单使用 `async / await` 并不能很好处理问题，因为当把异步的几个函数放到另一个函数，尽管在这个函数里面是做了同步处理的。但也仅仅是在这个函数里面实现了同步，相较于其它函数仍旧是异步的。

为此这个异步函数的 `new Promise()` 需要传递到更外层的函数，以此达到外层函数的同步效果。

``` JavaScript
const _async = new Promise(function (resolve, reject) {
    resolve('_async');
});

// ... some code ...

function async example () {
    // ... some code ...
}

// ... some code ...

await example();

return _async;

```

我是通上面的代码设计的，最终在高阶函数实现了同步，且代码结构简洁易懂。详见函数 `async database()` 的设计。
